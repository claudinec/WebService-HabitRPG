package WebService::HabitRPG;
use v5.010;
use strict;
use warnings;
use autodie;
use Moo;
use WWW::Mechanize;
use Method::Signatures;
use JSON::Any;

# ABSTRACT: Perl interface to the HabitRPG API

# VERSION: Generated by DZP::OurPkg:Version

=for Pod::Coverage BUILD DEMOLISH

=cut

has 'api_token'  => (is => 'ro'); # aka x-api-key
has 'user_id'    => (is => 'ro'); # aka x-api-user
has 'agent'      => (is => 'rw');
has '_last_json' => (is => 'rw'); # For debugging

use constant URL_BASE => 'https://habitrpg.com/api/v1';

sub BUILD {
    my ($self, $args) = @_;

    # Set a default agent if we don't already have one.

    if (not $self->agent) {
        $self->agent(
            WWW::Mechanize->new(
                agent => "Perl/$], WebService::HabitRPG/" . $self->VERSION,
            )
        );
    }

    return;
}

method user()       { return $self->_get_request( '/user'        ); }

method user_tasks($type where qr{^(?: habit | daily | todo | reward | )$}x = "") {
    if ($type) {
        return $self->_get_request( "/user/tasks?type=$type" ); 
    }
    return $self->_get_request( "/user/tasks" ); 
}

method get_task($task_id) {
    return $self->_get_request("/user/task/$task_id");
}

method new_task(
    :$type! where qr{^(?: habit | daily | todo | reward )$}x,
    :$text!,
    :$completed,
    :$value = 0,
    :$note = '',
    :$up = 1,
    :$down = 1
) {

    # Magical boolification for JSONification.
    # TODO: These work with JSON::XS. Do they work with other backends?

    $up   = $up   ? \1 : \0;
    $down = $down ? \1 : \0;

    # TODO : The API spec doesn't allow the submission of up/down
    # values, but I feel that *should* be allowed, otherwise
    # creating goals isn't full-featured.

    my $payload = $self->_encode_json({
        type      => $type,
        text      => $text,
        completed => $completed,
        value     => $value,
        note      => $note,
        up        => $up,
        down      => $down,
    });

    my $req = $self->_build_request('POST', '/user/task');

    $req->content( $payload );

    return $self->_request( $req );

}

# Convenience methods
method up  ($task) { return $self->updown($task, 'up'  ); }
method down($task) { return $self->updown($task, 'down'); }

# Returns: {"exp":11,"gp":12.416828586491677,"hp":50,"lvl":2,"delta":1}

method updown(
    $task!,
    $direction! where qr{up|down}
) {

    my $url = 'https://habitrpg.com/v1/users/' . $self->user_id . '/tasks/' . $task . '/' . $direction;

    my $req = HTTP::Request->new( 'POST', $url);
    $req->header( 'Content-Type' => 'application/json');
    $req->content( $self->_encode_json({ apiToken => $self->api_token }) );

    return $self->_request( $req );
}

method _get_request($url) {
    my $req = $self->_build_request('GET', $url);
    return $self->_request( $req );
}

# I don't like the name here, but this makes our request, and decodes
# the JSON-filled result

method _request($req) {
    return $self->_decode_json($self->agent->request( $req )->decoded_content);
}

method _build_request($type, $url) {

    my $req = HTTP::Request->new( $type, URL_BASE . $url );
    $req->header( 'Content-Type'    => 'application/json');
    $req->header( 'x-api-user'      => $self->user_id    );
    $req->header( 'x-api-key'       => $self->api_token  );

    return $req;
}

my $json = JSON::Any->new;

method _decode_json($string) {
    $self->_last_json($string);         # For debugging
    return $json->decode( $string );
}

method _encode_json($string) {
    return $json->encode( $string );
}

1;
